Изображение - I = g(x, y) = {x in [x_0, x_1], y in [y_0, y_1]}
в дискр. виде: g(i, j) = {i in [1, n], j in [1, m]}

Цвет - это результат взаимодействия света, сцены и зрительной сис-мы.
Видимый цвет - это результат взаимодействия спектра излучаемого света и поверхности 

Линейная цветовая модель RGB
Основные цвета - монохроматические.

Лин. называется так как выполняется з-он Грассмана:
Пусть даны два источника света, тогда объединеный поток света есть сумма их координат.

Восстановление баланса белого:
Модель серого мира:
X'=X* (Avg / X_), где 
X=[R, G, B]
X_ = 1/N * sum X(x, y)
Avg = (R_ + G_ + B_) / 3
X' = X * Avg / X_

Гистограмма - это график распределения яркостей на изображении.
На гор. оси - щкала яркостей тонов от черного до белого 
На верт. оси - число пикселей заданной яркости 

Коррекция - преобразование яркостей, компенсирующие нежелательный эффект.
f^-1(y) = x, y - ориг. изображение

линейная коррекция: линейное растяжение диапазона, так что самый темный пиксел становится 
черным а самый белый белым.  
f^-1(y) = (y-y_min)*(255-0)/(y_max-y_min)

нелинейная коррекция:
1. гамма-коррекция: коррекция для правильного отображения на мониторе
y = c * x^gamma
2. логарифмическая: сжатие динам. диапазона при визуализации 
y = c * log(1+x)

Цветовая коррекция:
Растяжение контрастности: растянуть интенс. по каждому из каналов на весь диапазон
(X-X_min)*(255-0)/(X_max-X_min), X = [R, G, B]

Подавление шума:
Фильтрация - усреднение пиксела по окрестности вокруг него.
Веса фильтрации - наз. ядром фильтра. Это квадратная матрица.
Свертка изображения f с помощью ядра g задается как:
(f*g)[m,n] = sum k,l of f[m-k,n-l]g[k,l]
Соглашение - ядро фильтра "переворачивается" вверх дном.

Св-ва свертки:
1. filter(f_1+f_2) = filter(f_1) + filter(f_2) линейность
2. filter(shift(f)) = shift(filter(f)) инвариантность к сдвигу
вторичные св-ва:
3. f * filter = filter * f
4. f * (filter_1 * filter_2) = f * (filter_1 * filter_2)
5. f * (filter_1 + filter_2) = f * filter_1 + f * filter_2
6. f * (k*filter) = k(f * filter)
7. f * e = f

Фильтрация на краях изображение:
1. Вернуть изображение меньше размером
2. (clip filter) Дополнение черным пикселом 
3. (wrap around) "Завернуть" изображение - дополняем зацикливанием (снизу пикселями сверху в начале и т.д.)
4. (cope edge) копирование последних строк и столбцов изображения
5. (reflect across edge) отражаем недостающие строки и столбцы изображения

Простейшие фильтры:
[0,0,0; 0, 1, 0; 0, 0, 0] - ничего не меняет
[0,0,0; 0, 0, 1; 0, 0, 0] - сдвиг влево
1/9*[1,1,1; 1, 1, 1; 1, 1, 1] - усреднение
ядро гаусса sigma=3 - фильтр размытия, является фильтром низких частот (подавляет высокие частоты), 
есть смысл использовать большое ядро, по сути он позволяет разделить изображение на 
сигналы разных частот и обрабатывать их независимо
для распараллеливания процесса фильтрации по гауссу используется св-во его сепарабельности:
его ядро раскладывается в произведение двух одномерных фильтров гаусса.
Делается это так:
1. изображение раскладывается на произведение вектора столбца и строки 
2. применяем свертку по строкам (используем св-во 3)
3. применяем свертку по столбцу к результату выше

Три вида шума:
соль и перец - случайные черные и белые пиксели, подавляется медианным фильтром (из окрестности 3х3 выбирает медиану)
так же этот фильтр устраняем тонкие линии\окружности
импульсный - случайные белые пиксели
гауссов - колебания яркости, распред. по норм. з-ну, подавляется гауссовым фильтром 

При сглаживании теряются высокие частоты.
Чтобы повысить резкость нужно из оригинала "вычесть" сглаженное изображение (получить высокие частоты)
и добавить полученный результат к оригиналу с некоторым коэффициентом 

Это фильтр unsharp он повышает резкость:
f+alpha*(f-f*g)=f*((1+alpha)e-alpha*g)

Компенсация разности освещения:
Положим что изображение формируется произведением объекта с картой освещенности:
I(i,j) = r(i,j)*l(i,j)
алгоритм Single scale retinex:
1. получить изображение освящения с помощью фильтра Гаусса
l'(i,j) = G*I(i,j)
2. восстановить изображение по формуле
r' = log(I(i,j)) - log(l'(i, j))
многомасштабный вариант: как правило 3 масштаба и веса одинаковые (1/3)
r' = sum k of w_k*(log(I(i,j)) - log(G_k(i,j)*I(i,j)))

Метрики качества изображений:
1. среднеквадратичная ошибка
MSE = 1/N sum i of (x_i - y_i)^2 
2. пиковое отношение сигнал\шум 
PSNR (в dB) = 10 *(2*lg(M) - lg(MSE)), где M макс значение яркости пикселя 

спецэффекты:
1. Тиснение
фильтр ([0,1,0;1,0,-1;0,-1,0] ) + сдвиг яркости + нормировка
2. Цифровой негатив
X'=255-X, X=[R,G,B]
3. светящиеся края
медианный фильтр + выделение краев + фильтр "максимума" (максимум между оригиналом и выделенным фильтром)
4. Перенос(сдвиг)\поворот
5. "Волны" (сдвиг по синусоиде)
6. Эффект стекла, случайный сдвиг
---------------------------------------------------------------------
СОПОСТАВЛЕНИЕ ШАБЛОНОВ:
1. фиксация объекта
2. Описать его изображением (шаблоном)
3. Задача - найти объект в изображении
4. Ограничить возможные преобразования объекта 
5. Поиск объекта в изображении по пиксельном сравнением с шаблоном

метрики для поиска шаблона:
Sum of abs dif (SAD) |x-y|
Sum of square dif (SSD) (x-y)^2
Cross-correlation (CC) a*b

для поиска
SAD, SSD -> min
CC -> max

освещенность нужно нормализовать или выравнять
нормализация освещенности:
I' = (I-I_avr)/||I-I_avr|| норм пиксель в диапазоне [-1;1], где 
I_avr = 1/N sum i, j of I(i,j)
||I|| = sqrt(sum i,j of I(i,j)**2) - норма интенсивности 

- метода:
ищет один конкретный объект а не все класс объектов
работает на практике плохо
+ метода:
эффективно применяется в видео (сначала хорошим методом находиться объект, потом так как 
вряд ли он сильно меняется от кадра к кадру ищем его сопоставлением - это быстрее чем искать 
объект на каждом кадре с 0)
---------------------------------------------------------------------
ВЫДЕЛЕНИЕ ГРАНИЦ:
цель - выделить самую значимую для поиска часть изображения,
для обобщения и прироста производительности сопоставления
край - это точка резкого изменения значений ф-ции интенсивности
изображения, т.е. экстремум данной ф-ции.
градиент будет направлен в сторону наибольшего изменения интенсивности
заменим частные производные разностным их приближением
т.к. она линейная и инвариантна к сдвигу то мб является рез-ом свертки 
т.о. фильтр [-1, 1] будет находить производную f по x с dx = 1

приближенно вычислить производную по направлению позволяют фильтры ниже:
1. Робертс:
[-1 0; 0 1], [0 -1; 1 0]
2. Превитт
[-1 -1 -1;0 0 0;1 1 1], [-1 0 1;-1 0 1;-1 0 1]
3. Собель - топ
[-1 -2 -1;0 0 0;1 2 1], [-1 0 1; -2 0 -2; -1 0 1]

шум крайне негативно влияет на вычисление производных, от него необходимо избавляться.
причем можно сэкономить 1 операцию - сначала вычислить производную фильтра и использовать ее 
при фильтрации.

не стоит забывать что чем больше размерность ядра тем больше размытие - края будут тоже размываться

критерии качества детектора краев:
1. надежность - выдает мало пропущенных краев и ложных
2. точная локализация - найденный край должен быть максимально близко к истинному краю
3. единственный отклик - выдача одной (в идеале) точки для одной точки истинного края 
4. связанность - какие пиксели принадлежат одной линии края

детектор Canny:
1. фильтрация изображение производной от фильтра Гаусса
2. поиск норму и направление градиента 
3. выделение локальные максимумы и утоньшение в несколько пикселей до 1
4. гистерезис - связывание краев и обрезание по порогу (нижний порог для продолжения кривых, верхний для их инициализации)
 
минусы Canny:
одинаково определяет края не придавая им семантики (более важные края могут быть заметны хуже или вовсе пропускаться)

метрики для сравнения краев шаблона A и изображения B:
1. Чамфер - сумма отклонений края шаблона от края картинки
ChDist(A, B) = sum a in A of min by b in B of ||a-b||
нужна нормализация
симметричная
2. Хаусдорф - макс отклонение края шаблона от края картинки 
HausDist(A, B) = max a in A of min b in B of ||a-b||
ненужна нормализация
несимметричная

Distance transform:
Для каждого пикселя вычисляется расстояние до ближайшего пикселя края, для краев оно 0
применение: 
1. совместив шаблон и карту DT вычислим сумму элементов DT которые попали на края 
шаблона - это будет значение ошибки
2. поиск осей объекта ("скелета") - если визуализировать DT то чем ярче пиксель тем дальше он от границ 

В итоге суммарно метод сопоставления шаблонов:
Подходит тогда когда объекты фиксированные и модель преобразований не сложная
пример: цифры\буквы, поиск объектов на аеро\космических снимках
Сами метода сопоставления не быстрые и требуют ускорений
---------------------------------------------------------------------
БИНАРИЗАЦИЯ ИЗОБРАЖЕНИЯ - преобразование изображения в изображение, в котором фон имеет значение 0 
а объекты значение 1

пороговая фильтрация - 0 если яркость ниже порога, 1 иначе или наоборот

порог можно определить с помощью гистограммы в тех случаях, в которых изображение двух цветов
фон однотонный и занимает бОльшую часть изображения:
	1. сглаживание гистограммы
	2. поиск ячейки гистограммы с макс значением h_max - средний цвет фона
	3. поиск на той стороне гистограммы, которая не относиться к объекту (если фон ярче объектов то справа от h_max
	иначе слева), яркости h_p, кол-во пикселей с яркостью >= или <= (правее если фон ярче) h_p есть p% (мб 5) от пикселей яркости 
	которых >= или <= (правее если фон ярче) h_max
	4. пересчитать порог T = h_max - (h_p - h_max) = 2*h_max - h_p

однако если освещение не равномерное, то метод не применим.
в таких случаях нужно либо его выравнять либо применить адаптивную бинаризацию.

Адаптивная бинаризация:
Для каждого пикселя в его окрестности заданного радиуса высчитывается индивидуальный порог T.
Если I(i, j) > T(i, j) + C то 1, иначе 0
T = mean | median | (min+max) / 2

Если грамотно подобрать радиус и постоянную, то можно решить и задачу выравнивания освещения и бинаризации.

Когда не получается устранить шум или получить достаточную контрастность, нужно 
применять методы подавления шума на основе окрестностей пикселов.

Операции математической морфологии:
Пусть A объект обработки, а B инструмент
	1. Сужение (-) - логическое И
с увеличением размера и структуры инструмента можно удалить почти весь шум
однако размеры объектов сузятся 
	2. Расширение (+) - логическое ИЛИ, если хотя бы один пиксел из B совпал в окрестности то 1, иначе 0

коммутативный з-он:
A(+)B = B(+)A
A(-)B = B(-)A
ассоциативный з-он:
A(+)(B(+)С) = (A(+)B)(+)С
A(-)(B(-)С) = (A(-)B)(-)С

удачно подобрав размерность и структуру инструмента
можно решить следующие задачи:
шумоподавление
выделение границ объекта
выделение осей (скелета) объекта 
выделение сломанных зубьев на изображении шестерни

	3. Открытие - open(A, B) = (A(-)B)(+)B
тоже удаляет шум но не уменьшает объекты
недостаток - границы объектов сглаживаются 
	4. Закрытие - close(A, B) = (A(+)B)(-)B
удаляет шум на объектах

Мат морф не помогает если шум на бинарном изображении слишком сильный
тогда применяют медианный фильтр и мб после него мат морф если надо
---------------------------------------------------------------------
ВЫДЕЛЕНИЕ СВЯЗАННЫХ ОБЛАСТЕЙ 

связанная область - мн-во пикселей у каждого пикселя которого есть хотя бы 
один сосед, принадлежащий данному мн-ву.

4-связанность - соседи это все пиксели смежные по гориз или веритк
8-связанность - соседи это все пиксели смежные по гориз или веритк или диагонали

разметка связ областей - это размеченное изображение полученное из бинарного, в котором
пиксели каждого объекта равны его номеру 

метод последовательного сканирования:
будем последовательно обходить бинарное изображение слева-направо сверху-вниз
*С
BA

if A == 0: # фон
	continue
if B <= 1 and C <= 1:
	A = new_number
	new_number += 1
elif B > 1 xor C > 1:
	A = max(B, C)
else:
	if B == C:
		A = B
	else:
		A = min(B, C) # например
		table.push(A <=> B <=> C)

после всех итерация выше получаем выделенные связанные области + таблицу эквивалентности отметок 
---------------------------------------------------------------------
АНАЛИЗ ВЫДЕЛЕННЫХ ОБЛАСТЕЙ

числовые признаки областей:
1. геометрические
	главным образом интересуют инвариантные - то есть для объектов разных размеров но одной формы 
	значение признака не отличается
	I - бинарное!
	1. площадь S - кол-во пикселей в компоненте
	2. центр масс - пиксель с индексами (sum x of sum y of x*I(x,y) / S, sum x of sum y of y*I(x,y) / S)
		нужен в определении центрального момента 
		m[i,j] = sum (x,y) in S of (x-x*)^i * (y-y*)^j * I(x,y)
	3. компактность - отношение кв-та периметра к площади, где периметр это кол-во пикселей составляющих границу компоненты 
		это св-во инвариантно
		варианты подсчета пикселей периметра:
			внутренняя граница - пиксель в компоненте и хотя бы один его сосед НЕ в ней 
			внешняя граница - пиксель в НЕ компоненте и хотя бы один его сосед в ней 
			так же подсчет зависит от типа связанности компонент 
			
			получить контур объекта в бинарном изображении можно операциями ниже:
				1. внутренние оконтурирование C_in = A-(A(-)B)
				2. внешнее оконтурирование C_out = (A(+)B)-A
	4. ориентация главной оси инерции
		к повороту не является инвариантным , но иногда все равно полезно
		угол наклона главной оси = 0.5*arctan(2*m_11/(m_20-m_02))
	5. удлиненность (эксцентриситет) - приближение компоненты к норм распределению с не нулевой матрице ковариации 
		это св-во инвариантно, т.к. является отношением фокусного расстояния к большой полуоси эллипса 	
		elong = m_20+m_02+sqrt((m_20-m_02)^2 + 4*m_11^2) / (m_20+m_02-sqrt((m_20-m_02)^2 + 4*m_11^2))
2. фотометрические
	по исходному изображение для компонент в бинарном изображении 
	можно выделить признаки ниже:
	1. средняя яркость\цвет
	2. гисторама распределения яркости\цвета
	3. дисперсия яркостей\цвета

использование признаков:
1. подбор значений для классов объектов вручную - долго
	выписать наблюдения
	из них составить решающие правило
2. подбор диапазонов значений графически - нужна база и кол-во признаков усложняет 
	собрать базу:
		где только объекты obj_i
		где только шум
	строя графики пытаться найти закономерности
3. машинное обучение
	современный стандарт, причем от двух выше методов может работать даже при огромном кол-ве признаков
---------------------------------------------------------------------
ЛОКАЛЬНЫЕ ОСОБЕННОСТИ 

локальная особая точка - это точка отличающаяся от всех точек в некоторой окрестности

требования к особенностям
	1. повторяемость - особенность находиться в том же месте сцены не зависимо от освящения и точки обзора
	2. значимость - особенность имеет уникальное описание
	3. компактность - кол-во особенностей много меньше кол-ва пикселей 
	4. локальность - особенность занимает малую область изображения (не чувствительность к перекрытиям 
		объекта поиска другими объектами)

виды особенностей:
	1. углы - в области вокруг угла у градиента изображения два доминирующих направления 
	углы хорошо повторимы и различимы
	2. блобы - область изображения, в которой некоторые свойства, такие как интенсивность 
	или цвет, приблизительно постоянны
	3. область - примерно аналог блоба 

Детектор Лапласиана (блобы):
	для каждого пикселя вычисляется сверта с Лапласианами разного масштаба 
	и так как его максимум достигается при sigma=r/sqrt(2) вычислить характерный размер r окрестности 
	среди всех точек нужно выбирать устойчивые, то есть те макс которых ярко выражен 
	
	в многомасштабном варианте на разных масштабах свертываем изображение и ищем макс в 3 измерениях
	
	для повышения эффективности лапласиан заменяется разностью двух гауссианов 

Детектор Харриса (углы):
	изменение яркости в окрестности:
	E=sum x,y of w(x,y) [I(x+u,y+v)-I(x,y)]^2
	веса чаще всего либо одинаковые либо норм. распределение
	для малых u, v
	E(u,v) ~= [u v] M [u; v]
	M = sum x,y of w(x, y) [I_x^2, I_x*I_y; I_x*I_y, I_x*I_y] - матрица частных производных
	если одно из собственных значений близко к 0,то это не угол 
	Пусть R=detM-k(traceM)^2=lambda_1*lambda_2-k(lambda_1+lambda_2)^2, k in [0.04, 0.06]
	Тогда если |R| < eps то плоская область, 
			R < 0 то край
			R > 0 угол

	алгоритм Харриса
		1. Предварительно отфильтровав по Гауссу, вычислить градиент изображения в каждом пикселе
		2. Вычислить матрицу M по окну вокруг каждого пикселя 
		3. Вычислить отклик угла R
		4. Отрезать по порогу R
		5. Найти лок макс функции отклика по окрестности заданного радиуса 
		6. Выбрать N самых сильных лок макс

	инвариантость к преобразованиям:
		1. частичная к изменению освещенности - лок макс R не меняется одного ее значение увеличивается
		2. полная к повороту 
		3. НЕ инвариантен к масштабированию

Детектор Харриса-Лапласиана (углы):
	по изображению применяется харрис
	по масштабу лапласиан 

	в отличии от оригинального детектора инвариантен к масштабированию

проблема выбора точек в том что их желательно выбирать равномерно, однако сильные отклики сосредотачиваются иначе 

решением является адаптивный выбор точек по заданному радиусу:
	1. будем идти по точкам в порядке качества 
	2. для каждой точки выкинем из списка всех соседей в окрестности 
	3. если кол-во оставшихся точек больше, выберем радиус по меньше иначе по больше и так пока не найдем нужное кол-во

Детектор IBR (области):
	идти от лок экстремума яркости по лучам, считая f(t)=|I(t)-I_0|/[1/t int from 1 to t of |I(t)-I_0|],
	завершение при достижении пика f 

Детектор MSER (область):
	задать порог яркости 
	провести сегментацию по порогу 
	извлечь области 
	для каждой области найти порог при котором рост площади минимален
	описать вокруг области эллипс 

дескриптор - вектор признаков точки 

св-ва дескриптора:
	1. специфичность - разным точкам разный дескриптор
	2. локальность - зависит только от небольшой окрестности 
	3. инвариантность к освещению и преобразованиям
	4. простота вычисления

алгоритм SIFT:
	1. определить положение и масштаб особенности детектором блобов (Лапласиан, разность гауссианов)
	2. определить доминантную ориентацию по градиенту 
	3. использовать статистику по направлению градиента 

	устойчив к изменениям освещенности, небольшим сдвигам, повороту, масштабу

	вычисление ориентации:
		нужно найти направление градиентов пикселей окрестности 
		и построить их гистограмму направлений (угол направления [0;2pi]) 
		глоб максимум гистограммы будет соответствовать доминантному направлению 
		повернем окрестность так что бы дом градиент был направлен вверх 
		или "вырежем" прямоугольную область (rotation invariant frame) так что бы 
		дом градиент в ней был направлен вверх
		если макс по гистограмме несколько то "вырежем" несколько рамок (две) с разной ориентацией 

	таким образом мы выбрав rotation invariant frame для особенности 
	можем привести ее к некоему стандартному размеру 

	вычисление дескриптора:
		вычислить градиент в каждом пикселе
		построить гистограмму направлений градиентов по прямоуг. областям 
		вклад пикселей взвешивать по гауссиане с центром в центре окрестности
		по стандарту сетка 4х4 и в каждой гистограмма с 8 ячейками (вверх,вниз,вправо,влево+диаг)
		дескриптор есть вектор 128 длиной

сопоставление особенностей:
	сгенерировать пары-кандидатов - для каждой особенности первого изображения найти 
	несколько похожих по метрики на другом изображении

	выбор пар осуществляется приближенно с помощью структур данных (kd-tree, vocabulary trees, хеш-таблицы)

	спец метрики для дескрипторов:
		1. sum i 1 to n of min(d_1[i], d_2[i])
		2. (топ) sum i 1 to n of (d_1[i] - d_2[i])^2 / (d_1[i] + d_2[i])

	фильтрация пар-кандидатов:
		сравниваем расстояние первой ближайшей особенностью со второй ближайшей по метрики
		отношение будет большим для не оч "выделенных" особенностей 
		порог 0.8 хорошо себя показывает 

	MND(x,y) = NN(x,y)+NN(y,x), N(a,b) = 1 если b ближайший (по евклидову расст например) к a сосед, 
	если k-ый по близости то N(a,b) = k 











