РАСТРОВАЯ ГРАФИКА

TrueColor: 24\32 bit (8r, 8g, 8b) BGR(A)

в классич. варианте координата пикселя (x, y), у это строка 
на экране а х столбец!

линия:
	digital differential analyzer 
	slope = (y2-y1) / (x2-x1)
	x = x1, y = y1
	while x <= x2:
		set_pixel(x, int(y))
		y += slope 
		x += 1

	недостаток - использует вещ числы 

	алгоритм Брезенхема (центральной точки)
	(x-x1)/(x2-x1) = (y-y1)/(y2-y1)
	=> (x-x1)*dy - (y-y1)*dx = 0
	=> f(x,y) = x*dy - y*dx + y1*dx - x1*dy = 0
	f(x, y) > 0 - точка ниже прямой 
	f(x, y) = 0 - точка на прямой 
	f(x, y) < 0 - точка выше прямой 

	f(x1+1, y2+0.5) = dy - 0.5*dx
	e(x1+1, y2+0.5) = 2*f(x1+1, y2+0.5) = 2*dy - dx

	e = 2*dy - dx
	x = x1, y = y1
	set_pixel(x, y)
	while x <= x2:
		if e > 0:
			y += 1
			e += 2 * (dy-dx)
		else:
			e += 2*dy
		x += 1
		set_pixel(x, y)
	для оптимизации можно работать с приращениями в качестве отдельных переменных 

окружность:
	алгоритм Брезенхема (центральной точки)
	f(x,y) = x^2 + y^2 - R^2 
	f(x, y) > 0 - точка вне прямой 
	f(x, y) = 0 - точка на прямой 
	f(x, y) < 0 - точка внутри прямой 

	set_pixel_4(x, y, R):
		set_pixel(Cx, Cy-R)
		set_pixel(Cx, Cy+R)
		set_pixel(Cx-R, Cy)
		set_pixel(Cx+R, Cy)
		
	set_pixel_8(x, y):
		set_pixel(Cx+x, Cy+y)
		set_pixel(Cx-x, Cy+y)
		set_pixel(Cx+x, Cy-y)
		set_pixel(Cx-x, Cy-y)
		set_pixel(Cx+y, Cy+x)
		set_pixel(Cx-y, Cy+x)
		set_pixel(Cx+y, Cy-x)
		set_pixel(Cx-y, Cy-x)

	f(x+2, y-0.5)=f(x+1, y-0.5)+2x+3
	f(x+2, y-1.5)=f(x+1, y-0.5)+2x-2y+5
	f(1, R-0.5)=5/4-R
	для использования только целочисленных значений вычтем 1/4, можем сделать 
	так как на равенство не будем проверять

	e = 1-R
	x = 0, y = R
	set_pixel_4(x, y, R)
	while x <= y:
		if e > 0:
			y -= 1
			e += 2*(x-y)+5
		else:
			e += 2*x+3
		x += 1
		set_pixel_8(x, y)

	для оптимизации можно работать с приращениями отдельно
	incrSE = 5-2*R, incrE = 3 
		if e > 0:
			y -= 1
			e += incrSE
			incrSE += 4
		else:
			e += incrE
			incrE += 2

закраска области по цвету:
	тривиальное решение:
	добавлять смежные пиксели в стек\очередь
	закрашивать каждый пиксель если цвет соответствующий 
	оптимизация: закрашивать построчно 
--------------------------------------------------------------------------------
ПРЕОБРАЗОВАНИЯ

аффиные преобразования:
	все преобразования выполняем в однородных координатах (x, y) -> (x, y, 1), (x, y, w) -> (x/w, y/w)
	полагаем что множим точки на них справо т.е. (М_n*...*М_1*M_0)*v
	параллельный перенос:
		1 0 0 dx 
		0 1 0 dy 
		0 0 1 dz 
		0 0 0 1
	масштабирование:
		sx 0 0 0 
		0 sy 0 0 
		0 0 sz 0 
		0 0 0 1
	сдвиг (shearing):
		1 shxy shxz 0
		shyx 1 shyz 0 
		shzx shzy 1 0 
		0 0 0 1
	поворот вокруг произвольной оси:
		x^2*⁡ (1 - c) + c, x*y*(⁡ 1 - c) - z*s, x*⁢ z*(⁡ 1 - c) + y*⁢ s, 0 
		y*⁢ x*(⁡ 1 - c) + z*⁢ s, y^2 ⁡*(1 - c) + c, y⁢*z ⁡*(1 - c) - x*s, 0 
		x*⁢ z*(1 - c) - y*⁢ s, y*z*(1 - c) + x*s, z^2*(1 - c) + c, 0 
		0 0 0 1
		где с=cos(a), s=sin(a), норма вектора (x,y,z) = 1
		выведем эту матрицу, пусть дан вектор r и угол φ
		Чтобы получить матрицу поворота R(r, ф), можно сначала произвести ряд поворотов 
		относительно осей системы  OXYZ,  чтобы совместить ось r с осью  OZ.  Затем произведем
		требуемый поворот вокруг оси r на угол φ и опять ряд поворотов относительно осей 
		системы   OXYZ,   возвращающих ось   OZ   в исходное положение:
		R(r, ф) = R(x, -a)*R(y, b)*R(z, ф)*R(y, -b)*R(x, a)
		так как sin(a) = r_y/sqrt(r_y^2+r_z^2), cos(a)=r_z/sqrt(r_y^2+r_z^2)
		sin(b)=r_x, cos(b)=sqrt(r_y^2+r_z^2)
		то после подстановке получаем матрицу выше 

	при переводе в однородные координаты w=0 если мы хотим сохранить только направление 
	например для нормалей и векторов (не точек\радиус-векторов) это удобно!
	однако матрицы любых преобразований для нее будут иными

проективные преобразования:
	Результатом этого преобразования является преобразование 
	координат вершин видимой области сцены для каждой из осей 
	координат, таким образом, чтобы они находились в интервале от –1 до 1.

	ортогональное:
		центр проекции в бесконечности
		2/(right - left) 0 0 -(right + left)/(right - left)
		0 2/(top - bottom) 0 -(top + bottom)/(top - bottom)
		0 0 -2/(farVal - nearVal) -(farVal + nearVal)/(farVal - nearVal)
		0 0 0 1
		где left, right - вертикальные пл-ти отсечения
		bottom, top - горизонтальные пл-ти отсечения
		nearVal, farVal - ближняя и дальняя пл-ти отсечения
		выведем эту матрицу
		выведем для x. по сути нужно перевести из отрезка [left, right]
		в отрезок [-1, 1], получаем равенство ниже
		(x_ndc - (-1))/(-1 - 1) = (x - left)/(right - left) = "точка в отрезке [0, 1]"
		=> x_ndc = x * 2/(right - left) - (right + left)/(right - left)
		для остальных аналогично 
	перспективное:
		центр проекции в точке
		2*⁢ nearVal/(right - left) 0 (right + left)/(right - left) 0 
		0 2*nearVal/(top - bottom) (top + bottom)/(top - bottom) 0 
		0 0 -(farVal + nearVal)/(farVal - nearVal) -2*farVal*nearVal/(farVal - nearVal)
		0 0 -1 0
		выведем эту матрицу
		выведем для z` от 1/z
		z`= A/z+B
		=> -1=-A/nearVal+B => A = 2*nearVal*farVal/(farVal-nearVal)
			1=-A/farVal+B     B = (farVal+nearVal)/(farVal-nearVal)
		домножим на (-z) и получим
		(-z)*z` = -(farVal + nearVal)/(farVal - nearVal)*z - 2*nearVal*farVal/(farVal-nearVal)
		выведем для x
		x_n = -nearVal/z*x in [left, right] - проекция на ближнюю пл-ть 
		=> x` = 2 * (x_n-left)/(right-left) - 1 in [-1, 1]
		после подстановки x_n домножим на (-z) и получим 
		(-z)*x`=2*⁢ nearVal/(right - left) * x + (right + left)/(right - left) * z
		аналогично с y 

		получили матрицу для преобразования (x, y, z, 1) -> (-z*x`,-z*y`,-z*z`, -z) 






















