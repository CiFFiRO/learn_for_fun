РАСТРОВАЯ ГРАФИКА

TrueColor: 24\32 bit (8r, 8g, 8b) BGR(A)

в классич. варианте координата пикселя (x, y), у это строка 
на экране а х столбец!

линия:
	digital differential analyzer 
	slope = (y2-y1) / (x2-x1)
	x = x1, y = y1
	while x <= x2:
		set_pixel(x, int(y))
		y += slope 
		x += 1

	недостаток - использует вещ числы 

	алгоритм Брезенхема (центральной точки)
	(x-x1)/(x2-x1) = (y-y1)/(y2-y1)
	=> (x-x1)*dy - (y-y1)*dx = 0
	=> f(x,y) = x*dy - y*dx + y1*dx - x1*dy = 0
	f(x, y) > 0 - точка ниже прямой 
	f(x, y) = 0 - точка на прямой 
	f(x, y) < 0 - точка выше прямой 

	f(x1+1, y2+0.5) = dy - 0.5*dx
	e(x1+1, y2+0.5) = 2*f(x1+1, y2+0.5) = 2*dy - dx

	e = 2*dy - dx
	x = x1, y = y1
	set_pixel(x, y)
	while x <= x2:
		if e > 0:
			y += 1
			e += 2 * (dy-dx)
		else:
			e += 2*dy
		x += 1
		set_pixel(x, y)
	для оптимизации можно работать с приращениями в качестве отдельных переменных 

окружность:
	алгоритм Брезенхема (центральной точки)
	f(x,y) = x^2 + y^2 - R^2 
	f(x, y) > 0 - точка вне прямой 
	f(x, y) = 0 - точка на прямой 
	f(x, y) < 0 - точка внутри прямой 

	set_pixel_4(x, y, R):
		set_pixel(Cx, Cy-R)
		set_pixel(Cx, Cy+R)
		set_pixel(Cx-R, Cy)
		set_pixel(Cx+R, Cy)
		
	set_pixel_8(x, y):
		set_pixel(Cx+x, Cy+y)
		set_pixel(Cx-x, Cy+y)
		set_pixel(Cx+x, Cy-y)
		set_pixel(Cx-x, Cy-y)
		set_pixel(Cx+y, Cy+x)
		set_pixel(Cx-y, Cy+x)
		set_pixel(Cx+y, Cy-x)
		set_pixel(Cx-y, Cy-x)

	f(x+2, y-0.5)=f(x+1, y-0.5)+2x+3
	f(x+2, y-1.5)=f(x+1, y-0.5)+2x-2y+5
	f(1, R-0.5)=5/4-R
	для использования только целочисленных значений вычтем 1/4, можем сделать 
	так как на равенство не будем проверять

	e = 1-R
	x = 0, y = R
	set_pixel_4(x, y, R)
	while x <= y:
		if e > 0:
			y -= 1
			e += 2*(x-y)+5
		else:
			e += 2*x+3
		x += 1
		set_pixel_8(x, y)

	для оптимизации можно работать с приращениями отдельно
	incrSE = 5-2*R, incrE = 3 
		if e > 0:
			y -= 1
			e += incrSE
			incrSE += 4
		else:
			e += incrE
			incrE += 2

закраска области по цвету:
	тривиальное решение:
	добавлять смежные пиксели в стек\очередь
	закрашивать каждый пиксель если цвет соответствующий 
	оптимизация: закрашивать построчно 
--------------------------------------------------------------------------------
ПРЕОБРАЗОВАНИЯ

аффиные преобразования:
	все преобразования выполняем в однородных координатах (x, y) -> (x, y, 1), (x, y, w) -> (x/w, y/w)
	полагаем что множим точки на них справо т.е. (М_n*...*М_1*M_0)*v
	параллельный перенос:
		1 0 0 dx 
		0 1 0 dy 
		0 0 1 dz 
		0 0 0 1
	масштабирование:
		sx 0 0 0 
		0 sy 0 0 
		0 0 sz 0 
		0 0 0 1
	сдвиг (shearing):
		1 shxy shxz 0
		shyx 1 shyz 0 
		shzx shzy 1 0 
		0 0 0 1
	поворот вокруг произвольной оси:
		x^2*⁡ (1 - c) + c, x*y*(⁡ 1 - c) - z*s, x*⁢ z*(⁡ 1 - c) + y*⁢ s, 0 
		y*⁢ x*(⁡ 1 - c) + z*⁢ s, y^2 ⁡*(1 - c) + c, y⁢*z ⁡*(1 - c) - x*s, 0 
		x*⁢ z*(1 - c) - y*⁢ s, y*z*(1 - c) + x*s, z^2*(1 - c) + c, 0 
		0 0 0 1
		где с=cos(a), s=sin(a), норма вектора (x,y,z) = 1
		выведем эту матрицу, пусть дан вектор r и угол φ
		Чтобы получить матрицу поворота R(r, ф), можно сначала произвести ряд поворотов 
		относительно осей системы  OXYZ,  чтобы совместить ось r с осью  OZ.  Затем произведем
		требуемый поворот вокруг оси r на угол φ и опять ряд поворотов относительно осей 
		системы   OXYZ,   возвращающих ось   OZ   в исходное положение:
		R(r, ф) = R(x, -a)*R(y, b)*R(z, ф)*R(y, -b)*R(x, a)
		так как sin(a) = r_y/sqrt(r_y^2+r_z^2), cos(a)=r_z/sqrt(r_y^2+r_z^2)
		sin(b)=r_x, cos(b)=sqrt(r_y^2+r_z^2)
		то после подстановке получаем матрицу выше 

	при переводе в однородные координаты w=0 если мы хотим сохранить только направление 
	например для нормалей и векторов (не точек\радиус-векторов) это удобно!
	однако матрицы любых преобразований для нее будут иными

проективные преобразования:
	Результатом этого преобразования является преобразование 
	координат вершин видимой области сцены для каждой из осей 
	координат, таким образом, чтобы они находились в интервале от –1 до 1.

	ортогональное:
		центр проекции в бесконечности
		2/(right - left) 0 0 -(right + left)/(right - left)
		0 2/(top - bottom) 0 -(top + bottom)/(top - bottom)
		0 0 -2/(farVal - nearVal) -(farVal + nearVal)/(farVal - nearVal)
		0 0 0 1
		где left, right - вертикальные пл-ти отсечения
		bottom, top - горизонтальные пл-ти отсечения
		nearVal, farVal - ближняя и дальняя пл-ти отсечения
		выведем эту матрицу
		выведем для x. по сути нужно перевести из отрезка [left, right]
		в отрезок [-1, 1], получаем равенство ниже
		(x_ndc - (-1))/(-1 - 1) = (x - left)/(right - left) = "точка в отрезке [0, 1]"
		=> x_ndc = x * 2/(right - left) - (right + left)/(right - left)
		для остальных аналогично 
	перспективное:
		центр проекции в точке
		2*⁢ nearVal/(right - left) 0 (right + left)/(right - left) 0 
		0 2*nearVal/(top - bottom) (top + bottom)/(top - bottom) 0 
		0 0 -(farVal + nearVal)/(farVal - nearVal) -2*farVal*nearVal/(farVal - nearVal)
		0 0 -1 0
		выведем эту матрицу
		выведем для z` от 1/z
		z`= A/z+B
		=> -1=-A/nearVal+B => A = 2*nearVal*farVal/(farVal-nearVal)
			1=-A/farVal+B     B = (farVal+nearVal)/(farVal-nearVal)
		домножим на (-z) и получим
		(-z)*z` = -(farVal + nearVal)/(farVal - nearVal)*z - 2*nearVal*farVal/(farVal-nearVal)
		выведем для x
		x_n = -nearVal/z*x in [left, right] - проекция на ближнюю пл-ть 
		=> x` = 2 * (x_n-left)/(right-left) - 1 in [-1, 1]
		после подстановки x_n домножим на (-z) и получим 
		(-z)*x`=2*⁢ nearVal/(right - left) * x + (right + left)/(right - left) * z
		аналогично с y 

		получили матрицу для преобразования (x, y, z, 1) -> (-z*x`,-z*y`,-z*z`, -z) 

замечание для OpenGL:
	glMatrixMode(GL_MODELVIEW) - необходимо поставить вид матрицы до начала задания "мира"
	glTranslate, glRotate, glScale - множат текущую матрицу (GL_MODELVIEW\GL_PROJECTION) на указанную, то есть только 
	к векторам заданным ПОСЛЕ их вызова будет применено указанное преобразование
	glLoadIdentity - заменяет текущую матрицу на единичную
	glMatrixMode(GL_PROJECTION) - меняем тип матрицы после задания "мира" (стоит не забыть сразу после загрузить единичную)
	glOrtho, glFrustum - множат текущую матрицу на проективную матрицу 
--------------------------------------------------------------------------------
КРИВЫЕ И ПОВЕРХНОСТИ

кривые Безье:
линейные:
	B=P_0*(1-t)+P_1*t, t in [0;1]
	линейная интерполяция между двумя точками
квадратичные:
	композиция нескольких лин кривых
	B=P_0*(1-t)^2+2*P_1*(1-t)*t+P_2*t^2
	выведем ее, пусть даны P_0, P_1, P_2 и касательная 
	к кривой B пересекает отрезки P_0 P_1 и P_1 P_2 в точках
	Q_0 и Q_1. Тогда 
	B=Q_0*(1-t)+Q_1*t      
	Q_0=P_0*(1-t)+P_1*t  => подставив Q_0 и Q_1 в B получим уравнение выше 
	Q_1=P_1*(1-t)+P_2*t    
кубические:
	так же композиция нескольких лин кривых
	B=P_0*(1-t)^3+3*P_1*(1-t)^2*t+3*P_2*t^2*(1-t)+P_3*t^3
	выведем ее, пусть даны P_0, P_1, P_2, P_3 Q_0, Q_1, Q_2 
	лин крив Безье между P_0 и P_1, P_1 и P_2, P_2 и P_3 а касательная 
	к кривой B пересекает отрезки Q_0 Q_1 и Q_1 Q_2 в точках R_0 и R_1 
	которые так же являются лин кривыми Безье между Q_0 Q_1 и Q_1 Q_2
	Тогда B=R_0*(1-t)+R_1*t, подставив интерполяцию получим формулу выше 
общий случай:
	B=sum i from 0 to n of P_i*C_n^i*t^i*(1-t)^(n-i), где
	C_n^i = n!/(i!*(n-i)!)

интерполяция (Catmull-Rom):
	Пусть дан набор точек {R} нужно построить такую кривую
	в каждой точке которой существовала бы касательная к ней (производная).
	Возьмем точки R_i и R_i+1, так как кривые Безье гарантируют 
	прохождение кривой по первой и последним точкам, то пусть они и будут таковыми 
	и мы еще добавим между ними две точки, таким образом получим P_0=R_i, P_1, P_2, P_3=R_i+1
	зададим P_1 = P_0 + 1/6*(R_i+1 - R_i-1), P_2 = P_3 + 1/6*(R_i - R_i+2)
	замечание для краев: P_1=P_0 (начало)

B-сплайны:
	Кокс и де Бур:
	P(t)=sum i from 1 to n+1 of P_i*N_i,k(t), t in [t_min, t_max], k in [2, n+1]
	N_i,1= 1 if t in [x_i, x_i+1] else 0
	N_i,k=(t-x_i)*N_{i,k-1}(t)/(x_i+k-1 - x_i) + (x_i+k - t)*N_{i+1, k-1}(t)/(x_i+k - x_i+1)
	при этом будем полагать что 0/0=1
	x = [x_1; ...; x_n+k+1] - узловой вектор 

	NURBS:
	P(t)=sum i from 1 to n+1 of w_i*P_i*N_i,k(t)/sum i from 1 to n+1 of w_i*N_i,k(t)

поверхности Безье:
билинейные:
	даны точки P_00, P_01, P_10, P_11
	R_0 = P_00*(1-u)+P_01*u
	R_1 = P_10*(1-u)+P_11*u
	P(u, v) = R_0*(1-v)+R_1*v
бикубические:
	B(u, v) = [u^3, ..., 1] * M * [P_00, ..., P_03; ...; P_30, ..., P_33] * M^T * [v^3; ..; 1]
	M = [-1, 3, -3, 1; 3, -6, 3, 0;-3, 3, 0, 0; 1, 0, 0, 0]
	M = 1/6*[-1, 3, -3, 1; 3, -6, 3, 0;-3, 0, 3, 0; 1, 4, 1, 0] - uniform B-spline
	M = 1/2*[-1, 3, -3, 1; 2, -5, 4, -1;-1, 0, 1, 0; 0, 2, 0, 0] - Catmull-Rom
общий:
	B=sum i from 0 to n of sum j from 0 to m of P_ij * C_n^i*u^i*(1-u)^(n-i) * C_m^j*v^j*(1-v)^(m-j), где
	C_n^i = n!/(i!*(n-i)!)

поверхность Кунса:
	пусть даны граничные кривые P(u,0), P(u,1), P(0,v), P(1,v)
	билинейно их смешаем
	Q(u,v)=P(u,0)*(1-v)+P(u,1)*v+P(0,v)*(1-u)+P(1,v)*u-P(0,0)*(1-u)*(1-v)-
	-P(0,1)*(1-u)*v-P(1,0)*u*(1-v)-P(1,1)*u*v

трикубические пр-ва (free form deformation):
	B=sum i from 0 to n of sum j from 0 to m of sum k from 0 to l of P_ijk * C_l^k*w^k*(1-w)^(l-k) * 
	* C_n^i*u^i*(1-u)^(n-i) * C_m^j*v^j*(1-v)^(m-j), где
	C_n^i = n!/(i!*(n-i)!)































